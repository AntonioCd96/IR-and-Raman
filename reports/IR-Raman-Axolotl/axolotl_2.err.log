Traceback (most recent call last):
  File "/home/cd96/psi4conda/envs/jbook/lib/python3.11/site-packages/jupyter_cache/executors/utils.py", line 58, in single_nb_execution
    executenb(
  File "/home/cd96/psi4conda/envs/jbook/lib/python3.11/site-packages/nbclient/client.py", line 1305, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/cd96/psi4conda/envs/jbook/lib/python3.11/site-packages/jupyter_core/utils/__init__.py", line 166, in wrapped
    return loop.run_until_complete(inner)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/cd96/psi4conda/envs/jbook/lib/python3.11/asyncio/base_events.py", line 653, in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
  File "/home/cd96/psi4conda/envs/jbook/lib/python3.11/site-packages/nbclient/client.py", line 705, in async_execute
    await self.async_execute_cell(
  File "/home/cd96/psi4conda/envs/jbook/lib/python3.11/site-packages/nbclient/client.py", line 1058, in async_execute_cell
    await self._check_raise_for_error(cell, cell_index, exec_reply)
  File "/home/cd96/psi4conda/envs/jbook/lib/python3.11/site-packages/nbclient/client.py", line 914, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
import functools
import subprocess
import requests
import json
from ast import literal_eval
from pylab import *
from scipy.signal import argrelextrema
import pandas as pd
import glob
from rdkit import Chem
from rdkit.Chem.Draw import IPythonConsole
from rdkit.Chem import Draw
IPythonConsole.ipython_useSVG=True 
import ipywidgets as widgets
import pandas as pd
import numpy as np
import jax
import jax.numpy as jnp
from jax import grad, jit, vmap
from jax import random
from rdkit import Chem
from rdkit.Chem import AllChem
import py3Dmol
from ipywidgets import widgets, interact,fixed
from IPython.display import display
from matplotlib.offsetbox import OffsetImage, AnnotationBbox



def Animator_data(ID):
    # Opening JSON file
    f = open('crd.json')
 
    # returns JSON object as
    # a dictionary
    data = json.load(f)

    element_symbols = ['H', 'He', 'Li', 'Be', 'B', 'C', 'N', 'O', 'F', 'Ne', 'Na', 'Mg', 'Al', 'Si', 'P', 'S', 'Cl', 'Ar', 'K', 'Ca', 'Sc', 'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn',
    'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr', 'Rb', 'Sr', 'Y', 'Zr', 'Nb', 'Mo', 'Tc', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn', 'Sb', 'Te', 'I', 'Xe', 'Cs', 'Ba', 'La', 'Ce', 'Pr', 'Nd',
    'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb', 'Lu', 'Hf', 'Ta', 'W', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg', 'Tl', 'Pb', 'Bi', 'Po', 'At', 'Rn', 'Fr', 'Ra', 'Ac', 'Th',
    'Pa', 'U', 'Np', 'Pu', 'Am', 'Cm', 'Bk', 'Cf', 'Es', 'Fm', 'Md', 'No', 'Lr', 'Rf', 'Db', 'Sg', 'Bh', 'Hs', 'Mt', 'Ds', 'Rg', 'Cn', 'Nh', 'Fl', 'Mc', 'Lv', 'Ts', 'Og']

    
    
    freq = data[ID]["key_value_pairs"]["frequencies_cm"]
    freq= freq.replace("[", " ")
    freq=freq.replace("]", " ")
    freq=freq.replace("\n", " ")
    freq=freq.split()
    freqs_db = [round(float(i),2) for i  in freq ] 
    
    eq_pos = reshape(data[ID]["positions"]["__ndarray__"][2],\
                     (data[ID]["positions"]["__ndarray__"][0][0],\
                      data[ID]["positions"]["__ndarray__"][0][1]))
    at_num = data[ID]["numbers"]['__ndarray__'][2]
    elements = []
    for i in at_num:
        elements.append(element_symbols[i-1])
    
    modes = data[ID]["data"]["eigenvec"]
    
    with open('readme_solids.txt', 'w') as f:

        f.write("[Molden Format]")
        f.write('\n')
        f.write('\n')

        f.write("[FREQ]")
        f.write('\n')

        for line in freqs_db:
            f.write(str(line))
            f.write('\n')

        f.write('\n')
        f.write("[FR-COORD]")
        f.write('\n')
        for i in range(0,len(elements)):
            f.write(str(elements[i]))
            f.write('       ')
            f.write(str('%.8f' % round(eq_pos[i][0],8)))
            f.write('       ')
            f.write(str('%.8f' % round(eq_pos[i][1],8)))
            f.write('       ')
            f.write(str('%.8f' % round(eq_pos[i][2],8)))
            f.write('\n')
        f.write('\n')
        f.write("[FR-NORM-COORD]")
        f.write('\n')
        for vib in range(0,len(modes)):
            f.write("vibration {0}".format(vib+1))
            f.write('\n')
            for el in range(0,len(elements)):
                f.write('       ')
                f.write(str('%.8f' % round(modes[vib][el][0],8)))
                f.write('       ')
                f.write(str('%.8f' % round(modes[vib][el][1],8)))
                f.write('       ')
                f.write(str('%.8f' % round(modes[vib][el][2],8)))
                f.write('\n')
#####################33
def intensity_raman(raman_tensor):
    """ Average a Raman-activity tensor to obtain a scalar
    intensity. """

    # This formula came from D. Porezag and M. R. Pederson, Phys. Rev.
    # B: Condens. Matter Mater. Phys., 1996, 54, 7830.
    if raman_tensor==None:
        return 0
    else: 

        alpha = (
            (raman_tensor[0][0] + raman_tensor[1][1] + raman_tensor[2][2])
            / 3.0)
    
        beta_squared = 0.5 * (
            (raman_tensor[0][0] - raman_tensor[1][1]) ** 2
            + (raman_tensor[0][0] - raman_tensor[2][2]) ** 2
            + (raman_tensor[1][1] - raman_tensor[2][2]) ** 2
            + 6.0 * (raman_tensor[0][1] ** 2 + raman_tensor[0][2] ** 2 +
                raman_tensor[1][2] ** 2)
            )
    
        return (45.0 * alpha ** 2 + 7.0 * beta_squared)
def g(wavenumb_sweep, intensity_max, wavenumber_max, Ïƒ):
    G = intensity_max / (Ïƒ *sqrt(2 * pi)) * exp(-(wavenumb_sweep-wavenumber_max)**2 / (2*Ïƒ**2))
    new_y=array(G)  
    return new_y
def Gaus_norm( list_freq,list_int, sigma):
    ### Gausian function to broaden peaks
    wavenumb       = list(linspace(0,4000,10001))
    int_dft_m      = list_int + list(zeros(len(wavenumb)))
    x_dft          = list_freq + wavenumb
    
    all= []
    for i in range(len(int_dft_m )):
        all.append(tuple((x_dft[i],int_dft_m[i])))
    
    all.sort()
    x= []
    y= []
    for i in all:
        x.append(round(i[0],1))
        y.append(i[1])
    
    frequencies = x
    intensities = y
    
    # Crear un diccionario para realizar un seguimiento de las sumas de intensidades por frecuencia
    frequency_intensity_dict = {}
    
    for frequency, intensity in zip(frequencies, intensities):
    
        if frequency in frequency_intensity_dict:
            frequency_intensity_dict[frequency] += intensity
        else:
           
            frequency_intensity_dict[frequency] = intensity
    
    result_frequencies_dft = list(frequency_intensity_dict.keys())
    result_intensities_dft = list(frequency_intensity_dict.values())    
    
    
    wavenumb_dft   = result_frequencies_dft
    max_int    = max(result_intensities_dft)
    
    norm_int = []
    for i in result_intensities_dft:
        norm_int.append(i/max_int)
    
    ### Gausian function to broaden peaks
    pos_max    = argrelextrema(array(norm_int), np.greater)
    
    x          = array(wavenumb)
    
    all_curve = 0
    Ïƒ = sigma
    for i in pos_max[0]:
        all_curve += g(x, norm_int[i], wavenumb[i],Ïƒ)      
    broad_int = all_curve   
    
    ### Normalization
    
    max_y = max(broad_int)
    int_norm_dft = []
    
    for i in broad_int:
        int_norm_dft.append((i/max_y))
    return wavenumb, int_norm_dft, result_intensities_dft

#########################

def raman_solids_DB(ID, data):

    freq = data[ID]["key_value_pairs"]["frequencies_cm"]
    freq= freq.replace("[", " ")
    freq=freq.replace("]", " ")
    freq=freq.replace("\n", " ")
    freq=freq.split()
    freqs_db = [float(i) for i  in freq ] 
    ints_ram_t = []
    for i in data[ID]["data"]["raman_tensors"]:
        ints_ram_t.append(intensity_raman(i))
        
    int_db = data[ID]["data"]["Ramanactive"]["__ndarray__"][2]
    
    # freq_gn, int_gn, int_n = Gaus_norm(freqs_db,int_db,10)
    # plot(freq_gn, int_n, label= "DFT-DB-1")
    
    freq_gn, int_gn, int_n = Gaus_norm(freqs_db,ints_ram_t,10)
    return freq_gn, int_gn, int_n


#######################

def section(fle, begin, end):
    """
    yields a section of a textfile. 
    Used to identify [COORDS] section etc
    """
    with open(fle) as f:
        for line in f:
            # found start of section so start iterating from next line
            if line.startswith(begin):
                for line in f: 
                    # found end so end function
                    if line.startswith(end):
                        return
                    # yield every line in the section
                    yield line.rstrip()    

def parse_molden(filename='default.molden_normal_modes'):
    """
    Extract all frequencies, the base xyz coordinates 
    and the displacements for each mode from the molden file
    """
    all_frequencies = list(section(filename, '[FREQ]', '\n'))
    all_frequencies = [(float(freq),i) for i, freq in enumerate(all_frequencies)]
    coords = list(section(filename, '[FR-COORD]', '\n'))
    normal_modes = []
    for freq in range(len(all_frequencies)):
        if freq+1 != len(all_frequencies):
            normal_modes.append(list(section(filename, f'vibration {freq+1}', 'vibration')))
        else:
            normal_modes.append(list(section(filename, f'vibration {freq+1}', '\n')))
    return all_frequencies, coords, normal_modes

def draw_normal_mode(mode=0, coords=None, normal_modes=None):
    """
    draws a specified normal mode using the animate mode from py3Dmol. 
    Coming from psi4 units need to be converted from a.u to A. 
    """
    fac=1  # bohr to A
    xyz =f"{len(coords)}\n\n"
    for i in range(len(coords)):
        atom_coords = [float(m) for m in  coords[i][8:].split('       ')]
        mode_coords = [float(m) for m in  normal_modes[mode][i][8:].split('       ')]
        xyz+=f"{coords[i][0:4]} {atom_coords[0]*fac} {atom_coords[1]*fac} {atom_coords[2]*fac} {mode_coords[0]*fac} {mode_coords[1]*fac} {mode_coords[2]*fac} \n"
    view = py3Dmol.view(width=400, height=400)
    view.addModel(xyz, "xyz", {'vibrate': {'frames':10,'amplitude':1}})
    view.vibrate(10,2.,True,{"radius": 0.15,
                          "radiusRadio":0.8,
                          "mid":30, "color":"#8db600"})
    view.setStyle({'sphere':{'scale':0.30},'stick':{'radius':0.25}})
    view.setBackgroundColor('0xeeeeee')
    view.animate({'loop': 'backAndForth'})
    view.zoomTo()
    return(view.show())

def show_normal_modes(filename='default.molden_normal_modes'):
    """
    wrapper function that parses the file and initializes the widget.
    """
    
    chemical_formula   = data[ID]["data"]["chemical_formula"]
    lattice_parameters = data[ID]["data"]["lattice_parameters"]
    lattice_angles     = data[ID]["data"]["lattice_angles"]
    cell_vectors       = array(data[ID]["cell"]["array"]["__ndarray__"][2]).reshape(3,3)
    mpid               = data[ID]["key_value_pairs"]["mpid"]
    density            = round(data[ID]["data"]["mass"]/data[ID]["data"]["volume"]*10**30*1.6726e-27,2)
    
    print("The chemical formula of this material is: ", chemical_formula)
    print("The lattice parameters of this material are, in the order (a,b,c) [A]: ", lattice_parameters)
    print("The lattice angles of this material are, in the order (Î±,Î²,Î³): ", lattice_angles)
    print("The cell vectors of this material are, in matrix notation: ")
    print(cell_vectors)
    print(r"The density of this material in [kg/m^3]: ", density)
    print("For more properties of the material you can consult it in the materials project webpage with the following ID: ", mpid)
    
    all_frequencies, coords, normal_modes =  parse_molden(filename=filename)
    _ = interact(draw_normal_mode, coords=fixed(coords), normal_modes=fixed(normal_modes), mode = widgets.Dropdown(
        options=all_frequencies,
        value=0,
        description='Normal mode:',
        style={'description_width': 'initial'}
    ))

 


------------------


[0;31m---------------------------------------------------------------------------[0m
[0;31mModuleNotFoundError[0m                       Traceback (most recent call last)
Cell [0;32mIn[1], line 17[0m
[1;32m     15[0m [38;5;28;01mimport[39;00m [38;5;21;01mpandas[39;00m [38;5;28;01mas[39;00m [38;5;21;01mpd[39;00m
[1;32m     16[0m [38;5;28;01mimport[39;00m [38;5;21;01mnumpy[39;00m [38;5;28;01mas[39;00m [38;5;21;01mnp[39;00m
[0;32m---> 17[0m [38;5;28;01mimport[39;00m [38;5;21;01mjax[39;00m
[1;32m     18[0m [38;5;28;01mimport[39;00m [38;5;21;01mjax[39;00m[38;5;21;01m.[39;00m[38;5;21;01mnumpy[39;00m [38;5;28;01mas[39;00m [38;5;21;01mjnp[39;00m
[1;32m     19[0m [38;5;28;01mfrom[39;00m [38;5;21;01mjax[39;00m [38;5;28;01mimport[39;00m grad, jit, vmap

[0;31mModuleNotFoundError[0m: No module named 'jax'

